# Chapter-2

## Insertion sort

The outer loop runs over all the elements except the first one, because the single-element prefix A[0:1] is trivially sorted, so the invariant that the first i+1 entries are sorted is true from the start. The inner loop moves element A[i] to its correct place so that after the loop, the first i+2 elements are sorted.

```c++
  int Insertionsort(/* arguments */) {
    // Assuming the index starts from 0

    for (i = 1; i < len(A); i++) {

      key = A[j] // store the data to swap
      j = i-1

      // Note: Always use j in the j loop only
      while (j>=0 and A[j]>key) {
      // swap here
        A[j+1] = A[j]
        j = j-1
      }
      A[j+1] = key
    }
    return 0;
  }
```      

## Method of Loop Invariants

- initialization
- Maintenance
- Termination

  - Insertion sort

        The in-dex j indicates the “current card” being inserted into the hand. At the beginning
        of each iteration of the for loop, which is indexed by j , the subarray consisting
        of elements A[1 .. j-1] constitutes the currently sorted hand, and the remaining
        subarray A[j+1 .. n] corresponds to the pile of cards still on the table.
        In fact, elements A[1.. j-1] are the elements originally in positions 1 through j-1,but
        now in sorted order. We state these properties of A[1..j-1] formally as a loop invariant
  - Logic of Loop invariant:
        At the start of each iteration of the for loop of lines 1–8, the subarray
        A[1 .. j-1] consists of the elements **originally** in A[1 .. j-1], but in sorted order.
  - Some really interesting Pseusdocode concepts are covered for Pseusdocode conventions to go over  

 **2.1-1** and **2.1-2**

 **`Answer`**

       Originally entered array is:
      31
      41
      59
      26
      41
      58
      The length of the array is:
      6
      Print the new array after the insertion sort
      26
      31
      41
      41
      58
      59
```c++
  #include <iostream>
  #include <cstdlib>
  using namespace std;

  void insertionsort(int *array, int l);
  void insertionsort_noninc(int *array,int l);
  int main(int argc, char *argv[]) {
    int array[6];
    cout<<"Enter 6 numbers:"<<endl;
    for (int i = 0; i < 6; ++i) {
        cin>>array[i];
    }
    cout<<endl;

    cout<<"Originally entered array is:"<<endl;
    for (int j = 0; j < 6; ++j) {
        cout<<array[j];
        cout<<endl;
    }
    int l = sizeof(array)/ sizeof(array[0]);

    cout<<"The length of the array is:"<<endl;
    cout<<l<<endl;
    insertionsort(array, l);
    insertionsort_noninc(array,l);
  }

  void insertionsort(int *array, int l) {

    for (int k = 1; k < l; ++k) {
        int key = array[k];
        int m = k-1;
        while (m>=0 && array[m]>key) {
            array[m+1]=array[m];
            m--;
        }
        array[m+1]=key;
    }
    cout<<"Print the new array after the insertion sort"<<endl;
    for (int n = 0; n < l; ++n) {
        cout<<array[n]<<endl;
    }
  }

  void insertionsort_noninc(int *array, int l){

    for (int i = 1; i < l; ++i) {
        int keyval = array[i];
        int j = i-1;
        while(j>=0 && array[j]<keyval){
            array[j+1] = array[j];
            j--;
        }
        array[j+1]=keyval;
    }
    cout<<"Array in non Icreasing sort"<<endl;
    for (int k = 0; k < l; ++k) {
        cout<<array[k]<<endl;
    }
  }
```
**2.1-3** Linear search Pseusdocode

    Before the start of the loop itself or 1st iteration , the value of index is NIL and after each iteration if the value v
    is not found then the value will still be NIL , and if the loop finishes the value at Termination will be also NIL
    This validates the principles of the Algorithm to hold true at every level

```C++
  //you have a value v to find using linear Search
  i = NIL
  for i = 0 to length(A) do
    if (A[i] == v) then
      return i
    end if  
    return NIL
  end for
```

**2.1-4** Summation of two n-bit intergers [A, B] to put into a (n+1) bit integer C
 + Assuming A and B already contain binary digits and I am not doing any addition , as any kind of addition will only be with intergers
 + Alternative solution also there, where we can consider interger addition and then mod
```C++
  carry = 0
  for i = 0 to n // consider index to start at 0
    if (A[n-i-1] == 1) and (B[n-i-1] == 1) then
      if (carry == 0) then
        c[n-i] = 1
        carry = 0
      else
        c[n-i] = 1
        carry = 1
      end if
    else
      if (carry == 0) then
        c[n-i] = 1
        carry = 0
      else
        c[n-i] = 0
        carry = 1
      end if    
    end if  
  end  for
  c[0] = carry
```

```C++
  carry = 0
  for i = 1 to n do // consider index to start from 1 and A and B traversal is from right to left
    c[i] = (A[i] + B[i] + carry)%2 // consider integer addition only
    if (A[i] + B[i] + carry)>=2 then
        carry = 1
    else
        carry = 0
    end if
  end for
  c[n+1]=carry     

```

  - Running time and Size of input(n) are very important parameters
  - The running time of an algorithm on a particular input is the number of primitive operations or “steps” executed.
  - Finding the cost of executing all the instructions for insertion sort, by assigning a cost to each statement
  - Typically for insertion sort the running time of the algorithm is fixed for a given input, there are randomized algorithms, whose behavior changes even with fixed input
  - The average case running time , is sometimes as bad as the worst case scenario, suppose you run insertion sort for half the time, ie, half of the array is sorted (for this case , t = j/2), even that will result in an^2 ie, quadratic order, as for the case of worst case running scenario
  - **rate of growth/ order of growth** - for the quadratic equation, we only consider the leading term
    + We usually consider one algorithm to be efficient , if it has a running time has higher order of growth will take less time for small inputs than an algorithm which has lower order of growth
    + Considering the worst case scenario, a lower order term will always run faster than a higher order term

**2.1-1**

**`Answer`**

    n^3

**2.1-2**

**`Answer`**

```C++
  for i = 1 to n-1 do
    min = i
    temp = A[i]
    for j = i+1 to n
      if A[j]<A[min] then
        min = j
      end if
    end for(j)    
    A[i] = A[min]
    A[min] = temp
  end for(i)
```
